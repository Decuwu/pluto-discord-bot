package.path = "lib\\?.lua"
package.cpath = "lib\\?.dll"
SOUP_WORKING_DIR = "lib\\"
soup = require "soup-apigen"

package.path = ""
package.cpath = ""
http = require "http"
json = require "json"
scheduler = require "scheduler"

soup_scheduler = soup.Scheduler.new()
scheduler.addloop(function()
	soup_scheduler:tick()
end)

local class DiscordChannelId
	__name = "DiscordChannelId"

	function __construct(public client, public id)
	end

	function sendTyping()
		self.client:sendRequest("POST", $"/channels/{self.id}/typing")
	end

	function sendMessage(content)
		self.client:sendRequest("POST", $"/channels/{self.id}/messages", {
			["content"] = content
		})
	end
end

local class DiscordMessage
	__name = "DiscordMessage"

	function mentionsMe()
		for self.mentions as mention do
			if mention.id == self.client.user.id then
				return true
			end
		end
		return false
	end

	function reply(content)
		self.client:sendRequest("POST", $"/channels/{self.channel.id}/messages", {
			["content"] = content,
			["message_reference"] = {
				["message_id"] = self.id
			}
		})
	end
end

local function new_with_data(bot, clazz, data)
	local inst = new clazz()
	inst.client = bot
	for k, v in data do
		inst[k] = v
	end
	return inst
end

local heartbeater = {}
heartbeater.last_sent = 0
function heartbeater.kickOff(ws, interval)
	scheduler.addloop(function()
		if heartbeater.last_seq and os.millis() - heartbeater.last_sent > interval then
			--print("sending heartbeat")
			ws:wsSend(json.encode({
				op = 1,
				d = heartbeater.last_seq
			}))
			heartbeater.last_sent = os.millis()
		end
	end)
end

return class
	__name = "DiscordBot"

	private token = nil
	user = {}

	private on_message = nil

	function __construct(token)
		self.token = token
		scheduler.add(function()
			print("Connecting to gateway.discord.gg...")
			local ewsct = soup.EstablishWebSocketConnectionTask.new("wss://gateway.discord.gg/")
			soup_scheduler:add(ewsct)
			while not ewsct:isWorkDone() do
				coroutine.yield()
			end
			local ws = ewsct:getSocket()
			print("Connected to gateway.")
			local p = ws:wsRecv()
			while p:isPending() do
				coroutine.yield()
			end
			local data = p:getData()
			print(data)
			heartbeater.kickOff(ws, json.decode(data).d.heartbeat_interval)
			local identify = [[{"op":2,"d":{"token":"]]
			identify ..= token
			identify ..= [[","capabilities":4093,"properties":{"os":"Windows","browser":"Chrome","device":"","system_locale":"en-GB","browser_user_agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36","browser_version":"111.0.0.0","os_version":"10","referrer":"","referring_domain":"","referrer_current":"","referring_domain_current":"","release_channel":"stable","client_build_number":182983,"client_event_source":null,"design_id":0},"presence":{"status":"online","since":0,"activities":[],"afk":false},"compress":false,"client_state":{"guild_versions":{},"highest_last_message_id":"0","read_state_version":0,"user_guild_settings_version":-1,"user_settings_version":-1,"private_channels_version":"0","api_code_version":0}}}]]
			ws:wsSend(identify)
			while true do
				p = ws:wsRecv()
				while p:isPending() do
					coroutine.yield()
				end
				data = p:getData()
				print(data)
				data = json.decode(data)
				if data.s then
					heartbeater.last_seq = data.s
				end
				if data.t then
					switch data.t do
						case "READY":
							self.user = data.d.user
							break
						case "MESSAGE_CREATE":
							if self.on_message then
								local msg = new_with_data(self, DiscordMessage, data.d)
								msg.channel = new DiscordChannelId(self, data.d.channel_id)
								scheduler.add(function()
									self.on_message(msg)
								end)
							end
							break
					end
				end
			end
		end)
	end

	function onMessage(f)
		self.on_message = f
	end

	static function run()
		scheduler.run()
	end

	function sendRequest(method, endpoint, body)
		endpoint = "https://discord.com/api/v10"..endpoint
		print($"[HTTP] Sending {method} request to {endpoint}")
		local options = {
			["method"] = method,
			["url"] = endpoint,
			["headers"] = {
				["Authorization"] = $"Bot {self.token}",
				["User-Agent"] = "DiscordBot (Please momma no spaghetti)",
			}
		}
		if body then
			options.headers["Content-Type"] = "application/json"
			options.body = json.encode(body)
		end
		local response = http.request(options)
		if response ~= "" then
			print($"[HTTP] Response: {response}")
		end
	end
end
