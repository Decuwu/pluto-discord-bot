package.path = ""
package.cpath = ""
http = require "http"
json = require "json"
scheduler = require "scheduler"
socket = require "socket"

package.path = "modules"..package.config:sub(1,1).."?.pluto"
require "websocket"

local class DiscordChannelId
	__name = "DiscordChannelId"

	function __construct(public client, public id)
	end

	function sendTyping()
		self.client:sendRequest("POST", $"/channels/{self.id}/typing")
	end

	function sendMessage(content)
		self.client:sendRequest("POST", $"/channels/{self.id}/messages", {
			["content"] = content
		})
	end
end

local class DiscordMessage
	__name = "DiscordMessage"

	function mentionsMe()
		for self.mentions as mention do
			if mention.id == self.client.user.id then
				return true
			end
		end
		return false
	end

	function reply(content)
		self.client:sendRequest("POST", $"/channels/{self.channel.id}/messages", {
			["content"] = content,
			["message_reference"] = {
				["message_id"] = self.id
			}
		})
	end
end

local function new_with_data(bot, clazz, data)
	local inst = new clazz()
	inst.client = bot
	for k, v in data do
		inst[k] = v
	end
	return inst
end

local class Heartbeater
	last_sent = 0

	function start(ws, interval)
		self.ws = ws
		scheduler.addloop(function()
			if self.ws ~= ws then
				return false
			end
			if self.last_seq and os.millis() - self.last_sent > interval then
				--print("sending heartbeat")
				self.ws:wsSend(json.encode({
					op = 1,
					d = self.last_seq
				}))
				self.last_sent = os.millis()
			end
		end)
	end

	function stop()
		self.ws = nil
	end
end

return class
	__name = "DiscordBot"

	private token = nil
	user = {}

	private on_message = nil

	function __construct(token)
		self.heartbeater = new Heartbeater()
		self.token = token
		scheduler.add(function()
			local ws = self.internal_openConnection()
			local data = ws:wsRecv()
			print(data)
			self.heartbeat_interval = json.decode(data).d.heartbeat_interval
			self.heartbeater:start(ws, self.heartbeat_interval)
			local identify = [[{"op":2,"d":{"token":"]]
			identify ..= token
			identify ..= [[","capabilities":4093,"properties":{"os":"Windows","browser":"Chrome","device":"","system_locale":"en-GB","browser_user_agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36","browser_version":"111.0.0.0","os_version":"10","referrer":"","referring_domain":"","referrer_current":"","referring_domain_current":"","release_channel":"stable","client_build_number":182983,"client_event_source":null,"design_id":0},"presence":{"status":"online","since":0,"activities":[],"afk":false},"compress":false,"client_state":{"guild_versions":{},"highest_last_message_id":"0","read_state_version":0,"user_guild_settings_version":-1,"user_settings_version":-1,"private_channels_version":"0","api_code_version":0}}}]]
			ws:wsSend(identify)
			return self:internal_runEventLoop(ws)
		end)
	end

	static function internal_openConnection()
		print("Connecting to gateway.discord.gg...")
		local ws = socket.connect("gateway.discord.gg", 443)
		if not ws:starttls("gateway.discord.gg") then
			error("TLS handshake failed.")
		end
		if not ws:wsUpgrade("gateway.discord.gg") then
			error("WebSocket upgrade failed.")
		end
		print("Connected to gateway.")
		return ws
	end

	function internal_runEventLoop(ws)
		while true do
			local data = ws:wsRecv()
			print(data)
			data = json.decode(data)
			if data.s then
				self.heartbeater.last_seq = data.s
			end
			switch data.op do
				case 0: -- Dispatch
					switch data.t do
						case "READY":
							self.user = data.d.user
							self.session_id = data.d.session_id
							self.resume_gateway_url = data.d.resume_gateway_url
							break
						case "MESSAGE_CREATE":
							if self.on_message then
								local msg = new_with_data(self, DiscordMessage, data.d)
								msg.channel = new DiscordChannelId(self, data.d.channel_id)
								scheduler.add(function()
									self.on_message(msg)
								end)
							end
							break
					end
					break
				case 7: -- Reconnect
					print("Remote is asking us to reconnect, dropping connection.")
					self.heartbeater:stop()
					ws = self.internal_openConnection()
					ws:wsSend(json.encode({
						op = 6,
						d = {
							token = self.token,
							session_id = self.session_id,
							seq = self.heartbeater.last_seq
						}
					}))
					data = ws:wsRecv()
					print(data)
					self.heartbeater:start(ws, self.heartbeat_interval)
					break
			end
		end
	end

	function onMessage(f)
		self.on_message = f
	end

	static function run()
		scheduler.run()
	end

	function sendRequest(method, endpoint, body)
		endpoint = "https://discord.com/api/v10"..endpoint
		print($"[HTTP] Sending {method} request to {endpoint}")
		local options = {
			["method"] = method,
			["url"] = endpoint,
			["headers"] = {
				["Authorization"] = $"Bot {self.token}",
				["User-Agent"] = "DiscordBot (Please momma no spaghetti)",
			}
		}
		if body then
			options.headers["Content-Type"] = "application/json"
			options.body = json.encode(body)
		end
		local response = http.request(options)
		if response ~= "" then
			print($"[HTTP] Response: {response}")
		end
	end
end
